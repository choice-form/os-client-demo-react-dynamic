这是一个基于React的动态组件加载的online survey clinet程序,它来自于种子仓库[os-client-seed-react](./),下面说明一些规则.

## 目录结构
这里对需要关注的一些目录结构的说明
+ config目录中放了一些配置,配置在不同环境中的一些资源和结构的地址
+ lang文件夹中放了多语言的文本,初始只有中文和英文.
+ src文件夹是项目代码
  + app 是主程序代码,答题端初始会加载这个程序,但是各个节点的组件还没加载
  + plugin 是动态加载的组件,开始答题时主程序会动态按需仅仅加载当前问卷需要用的组件.
    + standards目录中的是按节点类型标准划分的组件,进去第一层已经为每个类型的节点创建好的文件夹,这些文件夹名字是固定的,不能更改,在第二层,每个节点文件夹中已经实现了一个basic风格的组件,这个basic风格的组件是必须实现的.不能删除,除此之外,你能在第二层中basic的同级中为这个节点类型添加更多的风格,名字可以任意取.只有basic是名字不能变且必须存在的,其他风格的没有要求.
    + partials用于放置了比节点更低一级的共同组建,这里面没有限制,你可以添加任何名字和数量的组件,然后在standards中引用这里面的组件,如问题的头部所有题目都渲染成一样,则可以在partials中创建一个比如叫node-head的组件,然后standards中的节点组件在引用这个组件;同时partials中的某个组件也可以引用partials中的另一个组件.但是partials中的组件不能引用standards中的组件,
    > plugin目录中的引用规则:standards中的模块可以引用partials中的模块,partials中的模块可以引用partials中的模块,但是partials中的模块不能引用standards中的模块
  + utils目录用于放一些app和plugin中共同用到的模块
  > app和plugin是两个独立的程序,不能互相引用对方的模块,app可以引用utils,plugin也可以引用utils,反过来,utils不能引用plugin和app中的模块.

## 引用关系限制
箭头方向代表可引用的方向
+ app <=> app => utils <=> utils
+ plugin/standards => utils <=> utils
+ plugin/standards => plugin/partials <=> plugin/partials
+ plugin/partials <=> plugin/partials => utils <=> utils


## 自定义设置
从种子仓库为模板生成仓库后,需要自定义一些配置,再进行开发
+ 应用程序名称:需要在src/app/app.tsx中的Core.setup方法的参数中设置clientName属性,这个名字需要和是设计端中选择答题渲染程序中的名字一样,
+ 构建配置:build.json
```javascript
{
  devPort: ''// 本地开发是的服务启动端口
  assetsPath: { // 资源将会被放到的地址
    local: '' // 本地资源地址
    staging: '' // 测试环境资源地址
    prod: '' // 正式环境资源地址
  }
}
```
  

需要在build.json中更改地址,一般单独分离出的组件会被发布到我们的cdn上,这里设置后新的仓库组件会发布到的cdn的地址.
+ 

## 开始编写
+ 做好以上准备后就可以开发组件了
+ 通用的第三方资源在app中引入,每次都会被加载
+ 每个组件自己使用的资源在这个组件中引用,每个组件自己的样式需要按basic中的示例规则引入.
+ html模板参照index.html中的方式引入
+ 多语言直接应用utils中i18n中的translate方式进行翻译,可以搜索示例代码.

## 对接与调试
+ 这个仓库写好以后,设计端不知道的,所以设计端不会时候用这个程序,需要到设计端对接:把之前设置的本仓库的名称和发布后的程序地址写入到设计端主题管理器的代码中.
+ 本地启动项目
+ 打开设计端,发现主题管理器面板中的答题程序选择列表中会出现刚才添加的名称
+ 在下拉列表中选择时候用本项目作为答题程序,然后打开预览窗口,能看到预览窗口中显示的就是本项目的页面.
+ 修改一些本项目的代码,预览窗口会自动刷新.

## 理念
为了实现节点组件的动态按需加载,我们必须把主程序和插件程序分开,构建出来的资源也是分开的.
这样主程序初始运行起来的时候加载的东西就会很小,只有模板+路由引擎(如react,vue等),答题端核心包(os-client-core),主程序自己的代码和一些通用依赖的包,而节点组件的代码一个都还没加载

当开始渲染某些题目的时候,才会去需要渲染的某个类型的题目的某个风格的组件代码.这样的话如果问卷中只用两个题型的两个风格,则答题端从始至终就只会加载这两个组件,(当然开始和结束的组件必然是会加载的).

有了上面的机制,我们在节点类型增加,或因不同客户的需求对某个题型的展现方式发生巨大变化的时候,我们可以毫无负担的在plugin中添加新的题型组件,或者为某个题型添加新的风格组件,这样的横向扩展不再会使得答题端程序的加载包变大,使得以后的UI开放可以更自由.



